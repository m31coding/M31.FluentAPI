using M31.FluentApi.Generator.CodeBuilding;
using M31.FluentApi.Generator.CodeGeneration.CodeBoardActors.Commons;
using M31.FluentApi.Generator.CodeGeneration.CodeBoardActors.MethodCreation.Forks;
using M31.FluentApi.Generator.Commons;
using M31.FluentApi.Generator.SourceAnalyzers;
using M31.FluentApi.Generator.SourceGenerators;
using M31.FluentApi.Generator.SourceGenerators.AttributeElements;
using M31.FluentApi.Generator.SourceGenerators.Generics;
using Microsoft.CodeAnalysis;

namespace M31.FluentApi.Generator.CodeGeneration.CodeBoardElements;

// black board approach
internal class CodeBoard
{
    private readonly List<Diagnostic> diagnostics;
    private readonly Dictionary<string, SetMemberCode> memberToSetMemberCode;
    private readonly Dictionary<MethodIdentity, CallMethodCode> methodToCallMethodCode;

    private CodeBoard(
        IReadOnlyCollection<FluentApiInfo> fluentApiInfos,
        IReadOnlyCollection<FluentApiInfoGroup> fluentApiInfoGroups,
        BuilderAndTargetInfo builderAndTargetInfo,
        CodeFile codeFile,
        Class builderClass,
        string newLineString,
        CancellationToken cancellationToken)
    {
        FluentApiInfos = fluentApiInfos;
        FluentApiInfoGroups = fluentApiInfoGroups;
        Info = builderAndTargetInfo;
        CodeFile = codeFile;
        BuilderClass = builderClass;
        Constructor = null;
        StaticConstructor = null;
        memberToSetMemberCode = new Dictionary<string, SetMemberCode>();
        methodToCallMethodCode = new Dictionary<MethodIdentity, CallMethodCode>();
        BuilderMethodToAttributeData = new Dictionary<BuilderMethod, AttributeDataExtended>();
        Forks = new List<Fork>();
        BuilderClassFields = new BuilderClassFields();
        diagnostics = new List<Diagnostic>();
        NewLineString = newLineString;
        CancellationToken = cancellationToken;
    }

    internal IReadOnlyCollection<FluentApiInfo> FluentApiInfos { get; }
    internal IReadOnlyCollection<FluentApiInfoGroup> FluentApiInfoGroups { get; }
    internal BuilderAndTargetInfo Info { get; }
    internal CodeFile CodeFile { get; }
    internal Class BuilderClass { get; }
    internal Method? Constructor { get; set; }
    internal Method? StaticConstructor { get; set; }
    internal IReadOnlyDictionary<string, SetMemberCode> MemberToSetMemberCode => memberToSetMemberCode;
    internal IReadOnlyDictionary<MethodIdentity, CallMethodCode> MethodToCallMethodCode => methodToCallMethodCode;
    internal Dictionary<BuilderMethod, AttributeDataExtended> BuilderMethodToAttributeData { get; }
    internal IReadOnlyList<Fork> Forks { get; set; }
    internal BuilderClassFields BuilderClassFields { get; }
    internal IReadOnlyCollection<Diagnostic> Diagnostics => diagnostics;
    internal string NewLineString { get; }
    internal CancellationToken CancellationToken { get; }

    internal bool CancellationRequested => CancellationToken.IsCancellationRequested;
    internal bool HasErrors => diagnostics.HaveErrors();

    internal static CodeBoard Create(
        BuilderAndTargetInfo builderAndTargetInfo,
        IReadOnlyCollection<FluentApiInfo> fluentApiInfos,
        IReadOnlyCollection<FluentApiInfoGroup> fluentApiInfoGroups,
        IReadOnlyCollection<string> usingStatements,
        string newLineString,
        CancellationToken cancellationToken)
    {
        CodeFile codeFile = new CodeFile(builderAndTargetInfo.Namespace, newLineString);
        Class builderClass = new Class(builderAndTargetInfo.BuilderClassName);
        CodeBoard codeBoard = new CodeBoard(
            fluentApiInfos,
            fluentApiInfoGroups,
            builderAndTargetInfo,
            codeFile,
            builderClass,
            newLineString,
            cancellationToken);

        CreateHeader(codeFile);
        codeFile.AddPreprocessorDirective(
            "#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member");
        codeFile.AddPreprocessorDirective("#nullable enable");

        if (builderAndTargetInfo.GenericInfo != null)
        {
            foreach (GenericTypeParameter genericTypeParameter in builderAndTargetInfo.GenericInfo.Parameters)
            {
                builderClass.AddGenericParameter(
                    genericTypeParameter.ParameterString,
                    genericTypeParameter.Constraints.GetConstraintsForCodeGeneration());
            }
        }

        builderClass.AddModifiers(builderAndTargetInfo.FluentApiTypeIsInternal ? "internal" : "public");
        codeFile.AddDefinition(builderClass);

        foreach (string usingStatement in usingStatements)
        {
            codeFile.AddUsingStatement(usingStatement);
        }

        return codeBoard;
    }

    private static void CreateHeader(CodeFile codeFile)
    {
        codeFile.AddHeaderLine("// <auto-generated/>");
        codeFile.AddHeaderLine("// This code was generated by the library M31.FluentAPI.");
        codeFile.AddHeaderLine("// Changes to this file may cause incorrect behavior and will be lost if the code is " +
                               "regenerated.");
    }

    internal void AssignSetMemberCode(MemberSymbolInfo memberSymbolInfo, SetMemberCode setMemberCode)
    {
        string memberName = memberSymbolInfo.Name;

        if (memberToSetMemberCode.ContainsKey(memberName))
        {
            throw new GenerationException(
                $"{nameof(SetMemberCode)} for member {memberName} has already been assigned.");
        }

        memberToSetMemberCode[memberName] = setMemberCode;
    }

    internal void AssignCallMethodCode(MethodSymbolInfo methodSymbolInfo, CallMethodCode callMethodCode)
    {
        MethodIdentity methodIdentity = CreateMethodIdentity(methodSymbolInfo);

        if (methodToCallMethodCode.ContainsKey(methodIdentity))
        {
            throw new GenerationException(
                $"{nameof(CallMethodCode)} for method {methodIdentity.MethodName} has already been assigned.");
        }

        methodToCallMethodCode[methodIdentity] = callMethodCode;
    }

    internal CallMethodCode GetCallMethodCode(MethodSymbolInfo methodSymbolInfo)
    {
        return methodToCallMethodCode[CreateMethodIdentity(methodSymbolInfo)];
    }

    private static MethodIdentity CreateMethodIdentity(MethodSymbolInfo methodSymbolInfo)
    {
        return MethodIdentity.Create(methodSymbolInfo.Name,
            methodSymbolInfo.ParameterInfos.Select(i => i.TypeForCodeGeneration));
    }

    internal void ReportDiagnostic(Diagnostic diagnostic)
    {
        diagnostics.Add(diagnostic);
    }
}